# 2.2.1 keyed state

![](<../../../.gitbook/assets/image (12).png>)

上图示意了keyed stream与状态存储的关系。

## 案例--去重

我们来通过一个实际案例【对流去重，仅保留每个key的第一条】来学习keyed state实现。​

```java

// Some code
private static class Event { 
  public final String key; 
  ... 
} 

public static void main(String[] args) throws Exception { 
  StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();
  env.addSource(new EventSource())
    .keyBy(e -> e.key)
    .process(new Deduplicate())
    .print();
   env.execute(); 
 }
 
 public static class Deduplicate extends KeyedProcessFunction<String, Event, Event> {
  ValueState<Boolean> keyWasSeen;
​
  @Override
  public void open(Configuration conf) {
    ValueStateDescriptor<Boolean> desc = new ValueStateDescriptor<>("seen", Types.BOOLEAN);
    keyWasSeen = getRuntimeContext().getState(desc);
  }
​
  @Override
  public void processElement(Event event, Context context, Collector<Event> out) throws Exception {
    if (keyWasSeen.value() == null) {
      out.collect(event);
      keyWasSeen.update(true);
    }
  }
}
```

为了使用Flink的内置状态，我们需要：

* 使用一种Rich function
* 创建StateDescriptor，描述我们想要存储的数据
* 绑定本地定义的state变量到由Flink提供和维护的state上

### open

open()在初始化过程中被调用，此时尚未开始真正处理消息。

信息被打包成一种特定的Flink数据类型，在上面代码示例中是ValueState。ValueState是一种keyed state，意味着Flink为每个单独的key存储一个Boolean值。

这个算子的每个并行实例都会存储该实例维护一些keys的state。这是一种分片key-value存储。

### processElement

查看 processElement 方法的签名，我们发现它接收一个 Context 上下文参数。现在我们将忽略它，但是它(大多数情况下)用于实现计时器。

现在让我们看看 processElement 方法内部的业务逻辑。为了减少流的重复，我们检查是否已经看到了这个键的事件ーー即当前事件的键。

要检索状态值，我们调用. value ()方法。

要将新值存储到状态中，我们调用.update ()。

现在有一部分可能会令人困惑: 当调用 value ()和 update ()时，我们不必指定键。那么函数怎么知道当前访问的是哪个key对应的状态值？在框架调用 processElement ()方法之前，它已经自动确定了对正在处理的事件的键的作用域状态访问。

因此，重申一下: 我们已经要求 Flink 为我们管理状态，这意味着它将具有容错性，并且能够在单个实例的崩溃中存活。



## keyed state的分类



* ValueState\<T>
  * 最简单最通用的state类型
* ListState\<T>
  * 使用ListState\<T> 而不是ValueState\<List\<T>>，因为前者在内部做了很多优化
* MapState\<UK, UV>
  * 使用MapState\<UK, UV>，而不是ValueState\<HashMap\<UK,UV>>，原因同上。
  * MapState同样可以由key精准限定，这是一个嵌套Map
  * 此类型非常有用，例如，如果我们想为KeyedStream中每个key存储一个开放式属性Hash。
  * 另一种常见的模式，在处理乱序事件时间数据时，是使用 MapState 来存储不同时间点的数据。在这些场景中，MapState 条目是一个时间戳，与该时间点相关的数据组成一对。TODO关于这点我们后面在介绍窗口运算函数实现时会再仔细说明。
* ReducingState\<T>
  * reduce(...)内部使用
* AggregatingState\<IN, OUT>
  * aggregate(...)内部使用
  * ReducingState 和 AggregatingState 的存在是因为它们在 Flink 的实现中很方便——应用也可直接使用

## 状态的关键说明

​[https://mp.weixin.qq.com/s?\_\_biz=MzI4MzE4MjQxOQ==\&mid=2649387385\&idx=1\&sn=2c81a718ccaf730967909a3f8f5b87d3\&chksm=f3904545c4e7cc533af33fbfbe9e6e0215d1ecd123b8ef83a4ea01aebcd73941f6f53c7fe5d5](https://mp.weixin.qq.com/s?\_\_biz=MzI4MzE4MjQxOQ==\&mid=2649387385\&idx=1\&sn=2c81a718ccaf730967909a3f8f5b87d3\&chksm=f3904545c4e7cc533af33fbfbe9e6e0215d1ecd123b8ef83a4ea01aebcd73941f6f53c7fe5d5)

![](https://files.gitbook.com/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FQFcuSW2F0b7byl1FZWrg%2Fuploads%2FwPyr3IV6weLv8RwwKwGI%2Fimage.png?alt=media\&token=4635b7de-f0a6-4046-87f5-3dc2d588e7be)

上图示意了keyed stream与状态存储的关系。

##
